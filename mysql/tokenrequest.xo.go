package mysql

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
	"time"
)

// TokenRequest represents a row from 'oauth_proxy.token_requests'.
type TokenRequest struct {
	ID                   int          `json:"id"`                     // id
	App                  string       `json:"app"`                    // app
	RequestClientID      string       `json:"request_client_id"`      // request_client_id
	RequestClientSecret  string       `json:"request_client_secret"`  // request_client_secret
	RequestRefreshToken  string       `json:"request_refresh_token"`  // request_refresh_token
	RequestCode          string       `json:"request_code"`           // request_code
	RequestRedirectURL   string       `json:"request_redirect_url"`   // request_redirect_url
	RequestCodeVerifier  string       `json:"request_code_verifier"`  // request_code_verifier
	ResponseAccessToken  string       `json:"response_access_token"`  // response_access_token
	ResponseTokenType    string       `json:"response_token_type"`    // response_token_type
	ResponseRefreshToken string       `json:"response_refresh_token"` // response_refresh_token
	ResponseExpiry       sql.NullTime `json:"response_expiry"`        // response_expiry
	ResponseExtra        string       `json:"response_extra"`         // response_extra
	CreatedAt            time.Time    `json:"created_at"`             // created_at
	UpdatedAt            time.Time    `json:"updated_at"`             // updated_at
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the [TokenRequest] exists in the database.
func (tr *TokenRequest) Exists() bool {
	return tr._exists
}

// Deleted returns true when the [TokenRequest] has been marked for deletion
// from the database.
func (tr *TokenRequest) Deleted() bool {
	return tr._deleted
}

// Insert inserts the [TokenRequest] to the database.
func (tr *TokenRequest) Insert(ctx context.Context, db DB) error {
	switch {
	case tr._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case tr._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO oauth_proxy.token_requests (` +
		`app, request_client_id, request_client_secret, request_refresh_token, request_code, request_redirect_url, request_code_verifier, response_access_token, response_token_type, response_refresh_token, response_expiry, response_extra, created_at, updated_at` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?` +
		`)`
	// run
	logf(sqlstr, tr.App, tr.RequestClientID, tr.RequestClientSecret, tr.RequestRefreshToken, tr.RequestCode, tr.RequestRedirectURL, tr.RequestCodeVerifier, tr.ResponseAccessToken, tr.ResponseTokenType, tr.ResponseRefreshToken, tr.ResponseExpiry, tr.ResponseExtra, tr.CreatedAt, tr.UpdatedAt)
	res, err := db.ExecContext(ctx, sqlstr, tr.App, tr.RequestClientID, tr.RequestClientSecret, tr.RequestRefreshToken, tr.RequestCode, tr.RequestRedirectURL, tr.RequestCodeVerifier, tr.ResponseAccessToken, tr.ResponseTokenType, tr.ResponseRefreshToken, tr.ResponseExpiry, tr.ResponseExtra, tr.CreatedAt, tr.UpdatedAt)
	if err != nil {
		return logerror(err)
	}
	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return logerror(err)
	} // set primary key
	tr.ID = int(id)
	// set exists
	tr._exists = true
	return nil
}

// Update updates a [TokenRequest] in the database.
func (tr *TokenRequest) Update(ctx context.Context, db DB) error {
	switch {
	case !tr._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case tr._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with primary key
	const sqlstr = `UPDATE oauth_proxy.token_requests SET ` +
		`app = ?, request_client_id = ?, request_client_secret = ?, request_refresh_token = ?, request_code = ?, request_redirect_url = ?, request_code_verifier = ?, response_access_token = ?, response_token_type = ?, response_refresh_token = ?, response_expiry = ?, response_extra = ?, created_at = ?, updated_at = ? ` +
		`WHERE id = ?`
	// run
	logf(sqlstr, tr.App, tr.RequestClientID, tr.RequestClientSecret, tr.RequestRefreshToken, tr.RequestCode, tr.RequestRedirectURL, tr.RequestCodeVerifier, tr.ResponseAccessToken, tr.ResponseTokenType, tr.ResponseRefreshToken, tr.ResponseExpiry, tr.ResponseExtra, tr.CreatedAt, tr.UpdatedAt, tr.ID)
	if _, err := db.ExecContext(ctx, sqlstr, tr.App, tr.RequestClientID, tr.RequestClientSecret, tr.RequestRefreshToken, tr.RequestCode, tr.RequestRedirectURL, tr.RequestCodeVerifier, tr.ResponseAccessToken, tr.ResponseTokenType, tr.ResponseRefreshToken, tr.ResponseExpiry, tr.ResponseExtra, tr.CreatedAt, tr.UpdatedAt, tr.ID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the [TokenRequest] to the database.
func (tr *TokenRequest) Save(ctx context.Context, db DB) error {
	if tr.Exists() {
		return tr.Update(ctx, db)
	}
	return tr.Insert(ctx, db)
}

// Upsert performs an upsert for [TokenRequest].
func (tr *TokenRequest) Upsert(ctx context.Context, db DB) error {
	switch {
	case tr._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO oauth_proxy.token_requests (` +
		`id, app, request_client_id, request_client_secret, request_refresh_token, request_code, request_redirect_url, request_code_verifier, response_access_token, response_token_type, response_refresh_token, response_expiry, response_extra, created_at, updated_at` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?` +
		`)` +
		` ON DUPLICATE KEY UPDATE ` +
		`app = VALUES(app), request_client_id = VALUES(request_client_id), request_client_secret = VALUES(request_client_secret), request_refresh_token = VALUES(request_refresh_token), request_code = VALUES(request_code), request_redirect_url = VALUES(request_redirect_url), request_code_verifier = VALUES(request_code_verifier), response_access_token = VALUES(response_access_token), response_token_type = VALUES(response_token_type), response_refresh_token = VALUES(response_refresh_token), response_expiry = VALUES(response_expiry), response_extra = VALUES(response_extra), created_at = VALUES(created_at), updated_at = VALUES(updated_at)`
	// run
	logf(sqlstr, tr.ID, tr.App, tr.RequestClientID, tr.RequestClientSecret, tr.RequestRefreshToken, tr.RequestCode, tr.RequestRedirectURL, tr.RequestCodeVerifier, tr.ResponseAccessToken, tr.ResponseTokenType, tr.ResponseRefreshToken, tr.ResponseExpiry, tr.ResponseExtra, tr.CreatedAt, tr.UpdatedAt)
	if _, err := db.ExecContext(ctx, sqlstr, tr.ID, tr.App, tr.RequestClientID, tr.RequestClientSecret, tr.RequestRefreshToken, tr.RequestCode, tr.RequestRedirectURL, tr.RequestCodeVerifier, tr.ResponseAccessToken, tr.ResponseTokenType, tr.ResponseRefreshToken, tr.ResponseExpiry, tr.ResponseExtra, tr.CreatedAt, tr.UpdatedAt); err != nil {
		return logerror(err)
	}
	// set exists
	tr._exists = true
	return nil
}

// Delete deletes the [TokenRequest] from the database.
func (tr *TokenRequest) Delete(ctx context.Context, db DB) error {
	switch {
	case !tr._exists: // doesn't exist
		return nil
	case tr._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM oauth_proxy.token_requests ` +
		`WHERE id = ?`
	// run
	logf(sqlstr, tr.ID)
	if _, err := db.ExecContext(ctx, sqlstr, tr.ID); err != nil {
		return logerror(err)
	}
	// set deleted
	tr._deleted = true
	return nil
}

// TokenRequestByID retrieves a row from 'oauth_proxy.token_requests' as a [TokenRequest].
//
// Generated from index 'token_requests_id_pkey'.
func TokenRequestByID(ctx context.Context, db DB, id int) (*TokenRequest, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, app, request_client_id, request_client_secret, request_refresh_token, request_code, request_redirect_url, request_code_verifier, response_access_token, response_token_type, response_refresh_token, response_expiry, response_extra, created_at, updated_at ` +
		`FROM oauth_proxy.token_requests ` +
		`WHERE id = ?`
	// run
	logf(sqlstr, id)
	tr := TokenRequest{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, id).Scan(&tr.ID, &tr.App, &tr.RequestClientID, &tr.RequestClientSecret, &tr.RequestRefreshToken, &tr.RequestCode, &tr.RequestRedirectURL, &tr.RequestCodeVerifier, &tr.ResponseAccessToken, &tr.ResponseTokenType, &tr.ResponseRefreshToken, &tr.ResponseExpiry, &tr.ResponseExtra, &tr.CreatedAt, &tr.UpdatedAt); err != nil {
		return nil, logerror(err)
	}
	return &tr, nil
}
