package db

// Code generated by xo. DO NOT EDIT.

import (
	"context"
)

// TokenRequest represents a row from 'token_requests'.
type TokenRequest struct {
	ID                   int    `json:"id"`                     // id
	App                  string `json:"app"`                    // app
	RequestClientID      string `json:"request_client_id"`      // request_client_id
	RequestClientSecret  string `json:"request_client_secret"`  // request_client_secret
	RequestRefreshToken  string `json:"request_refresh_token"`  // request_refresh_token
	RequestCode          string `json:"request_code"`           // request_code
	RequestRedirectURL   string `json:"request_redirect_url"`   // request_redirect_url
	RequestCodeVerifier  string `json:"request_code_verifier"`  // request_code_verifier
	ResponseAccessToken  string `json:"response_access_token"`  // response_access_token
	ResponseTokenType    string `json:"response_token_type"`    // response_token_type
	ResponseRefreshToken string `json:"response_refresh_token"` // response_refresh_token
	ResponseExpiry       Time   `json:"response_expiry"`        // response_expiry
	ResponseExtra        string `json:"response_extra"`         // response_extra
	CreatedAt            Time   `json:"created_at"`             // created_at
	UpdatedAt            Time   `json:"updated_at"`             // updated_at
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the [TokenRequest] exists in the database.
func (tr *TokenRequest) Exists() bool {
	return tr._exists
}

// Deleted returns true when the [TokenRequest] has been marked for deletion
// from the database.
func (tr *TokenRequest) Deleted() bool {
	return tr._deleted
}

// Insert inserts the [TokenRequest] to the database.
func (tr *TokenRequest) Insert(ctx context.Context, db DB) error {
	switch {
	case tr._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case tr._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO token_requests (` +
		`app, request_client_id, request_client_secret, request_refresh_token, request_code, request_redirect_url, request_code_verifier, response_access_token, response_token_type, response_refresh_token, response_expiry, response_extra, created_at, updated_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14` +
		`)`
	// run
	logf(sqlstr, tr.App, tr.RequestClientID, tr.RequestClientSecret, tr.RequestRefreshToken, tr.RequestCode, tr.RequestRedirectURL, tr.RequestCodeVerifier, tr.ResponseAccessToken, tr.ResponseTokenType, tr.ResponseRefreshToken, tr.ResponseExpiry, tr.ResponseExtra, tr.CreatedAt, tr.UpdatedAt)
	res, err := db.ExecContext(ctx, sqlstr, tr.App, tr.RequestClientID, tr.RequestClientSecret, tr.RequestRefreshToken, tr.RequestCode, tr.RequestRedirectURL, tr.RequestCodeVerifier, tr.ResponseAccessToken, tr.ResponseTokenType, tr.ResponseRefreshToken, tr.ResponseExpiry, tr.ResponseExtra, tr.CreatedAt, tr.UpdatedAt)
	if err != nil {
		return logerror(err)
	}
	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return logerror(err)
	} // set primary key
	tr.ID = int(id)
	// set exists
	tr._exists = true
	return nil
}

// Update updates a [TokenRequest] in the database.
func (tr *TokenRequest) Update(ctx context.Context, db DB) error {
	switch {
	case !tr._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case tr._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with primary key
	const sqlstr = `UPDATE token_requests SET ` +
		`app = $1, request_client_id = $2, request_client_secret = $3, request_refresh_token = $4, request_code = $5, request_redirect_url = $6, request_code_verifier = $7, response_access_token = $8, response_token_type = $9, response_refresh_token = $10, response_expiry = $11, response_extra = $12, created_at = $13, updated_at = $14 ` +
		`WHERE id = $15`
	// run
	logf(sqlstr, tr.App, tr.RequestClientID, tr.RequestClientSecret, tr.RequestRefreshToken, tr.RequestCode, tr.RequestRedirectURL, tr.RequestCodeVerifier, tr.ResponseAccessToken, tr.ResponseTokenType, tr.ResponseRefreshToken, tr.ResponseExpiry, tr.ResponseExtra, tr.CreatedAt, tr.UpdatedAt, tr.ID)
	if _, err := db.ExecContext(ctx, sqlstr, tr.App, tr.RequestClientID, tr.RequestClientSecret, tr.RequestRefreshToken, tr.RequestCode, tr.RequestRedirectURL, tr.RequestCodeVerifier, tr.ResponseAccessToken, tr.ResponseTokenType, tr.ResponseRefreshToken, tr.ResponseExpiry, tr.ResponseExtra, tr.CreatedAt, tr.UpdatedAt, tr.ID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the [TokenRequest] to the database.
func (tr *TokenRequest) Save(ctx context.Context, db DB) error {
	if tr.Exists() {
		return tr.Update(ctx, db)
	}
	return tr.Insert(ctx, db)
}

// Upsert performs an upsert for [TokenRequest].
func (tr *TokenRequest) Upsert(ctx context.Context, db DB) error {
	switch {
	case tr._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO token_requests (` +
		`id, app, request_client_id, request_client_secret, request_refresh_token, request_code, request_redirect_url, request_code_verifier, response_access_token, response_token_type, response_refresh_token, response_expiry, response_extra, created_at, updated_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`app = EXCLUDED.app, request_client_id = EXCLUDED.request_client_id, request_client_secret = EXCLUDED.request_client_secret, request_refresh_token = EXCLUDED.request_refresh_token, request_code = EXCLUDED.request_code, request_redirect_url = EXCLUDED.request_redirect_url, request_code_verifier = EXCLUDED.request_code_verifier, response_access_token = EXCLUDED.response_access_token, response_token_type = EXCLUDED.response_token_type, response_refresh_token = EXCLUDED.response_refresh_token, response_expiry = EXCLUDED.response_expiry, response_extra = EXCLUDED.response_extra, created_at = EXCLUDED.created_at, updated_at = EXCLUDED.updated_at `
	// run
	logf(sqlstr, tr.ID, tr.App, tr.RequestClientID, tr.RequestClientSecret, tr.RequestRefreshToken, tr.RequestCode, tr.RequestRedirectURL, tr.RequestCodeVerifier, tr.ResponseAccessToken, tr.ResponseTokenType, tr.ResponseRefreshToken, tr.ResponseExpiry, tr.ResponseExtra, tr.CreatedAt, tr.UpdatedAt)
	if _, err := db.ExecContext(ctx, sqlstr, tr.ID, tr.App, tr.RequestClientID, tr.RequestClientSecret, tr.RequestRefreshToken, tr.RequestCode, tr.RequestRedirectURL, tr.RequestCodeVerifier, tr.ResponseAccessToken, tr.ResponseTokenType, tr.ResponseRefreshToken, tr.ResponseExpiry, tr.ResponseExtra, tr.CreatedAt, tr.UpdatedAt); err != nil {
		return logerror(err)
	}
	// set exists
	tr._exists = true
	return nil
}

// Delete deletes the [TokenRequest] from the database.
func (tr *TokenRequest) Delete(ctx context.Context, db DB) error {
	switch {
	case !tr._exists: // doesn't exist
		return nil
	case tr._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM token_requests ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, tr.ID)
	if _, err := db.ExecContext(ctx, sqlstr, tr.ID); err != nil {
		return logerror(err)
	}
	// set deleted
	tr._deleted = true
	return nil
}

// TokenRequestByID retrieves a row from 'token_requests' as a [TokenRequest].
//
// Generated from index 'token_requests_id_pkey'.
func TokenRequestByID(ctx context.Context, db DB, id int) (*TokenRequest, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, app, request_client_id, request_client_secret, request_refresh_token, request_code, request_redirect_url, request_code_verifier, response_access_token, response_token_type, response_refresh_token, response_expiry, response_extra, created_at, updated_at ` +
		`FROM token_requests ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, id)
	tr := TokenRequest{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, id).Scan(&tr.ID, &tr.App, &tr.RequestClientID, &tr.RequestClientSecret, &tr.RequestRefreshToken, &tr.RequestCode, &tr.RequestRedirectURL, &tr.RequestCodeVerifier, &tr.ResponseAccessToken, &tr.ResponseTokenType, &tr.ResponseRefreshToken, &tr.ResponseExpiry, &tr.ResponseExtra, &tr.CreatedAt, &tr.UpdatedAt); err != nil {
		return nil, logerror(err)
	}
	return &tr, nil
}
